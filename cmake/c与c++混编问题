今天遇到一个CMake 链接问题，这里提出来和大家分享：
问题：
自己用C语言写了一个动态:libword-counter.so，公开头文件word-counter.h, 其中有函数如：wc_get_word_freq()
自己用C++语言写了一个测试工程，在main函数中调用上述库函数wc_get_word_freq。
结果出现undefined reference to 的错误

分析：
1. 根据Cmake的编译log，可以看出该错误是在linking target的时候出现的，因此build是OK的
2. 如果修改头文件为其他文件，则出现找不到文件的错误，因此说明头文件可以正常找到。也在次说明1中build是没问题的
3. 编译选项我已经指明了需要加载的库 -lword-counter
4. 如果修改3中的库名，则出现找不到so的错误，说明3中编译选项是没问题的，系统能找到这个库so
5. 现在出现问题“undefined reference to 的错误”，太诡异了？
6. 本人一直坚信，计算机不会出现灵异事件，因此不断请教度娘
7. 发现有人建议我用nm命令查看so的符号表，看看这个函数是否正常，于是nm -D 库文件，查看了下，结果函数正常的。
8. 最后想到C++调用C存在混编问题，有人建议编译选项加上 -lstdc++，结果还是不行
9. 最终沿着混编问题走下去，我找到了原因，需要在库文件的头文件中加上下面的语句，用以指定，在编译C++的时候被调用的代码仍然使用C编译选项。


#ifdef __cplusplus
       extern "C" {
       #endif
       #ifdef __cplusplus
       }
       #endif



 一、extern“C”的作用（最重点）

    1. extern "C"的真实目的是实现类C和C++的混合编程。extern “C”是由Ｃ＋＋提供的一个连接交换指定符号，用于告诉Ｃ＋＋这段代码是Ｃ函数。extern “C”后面的函数不使用的C++的名字修饰,而是用C。这是因为C++编译后库中函数名会变得很长，与C生成的不一致，造成Ｃ＋＋不能直接调用C函数。

    2.C++语言支持函数重载，C语言不支持函数重载。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为：void foo(int x, int y);该函数被C编译器编译后在库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。C++提供了C连接交换指定符号extern“C”来解决名字匹配问题。

    3.被extern "C"限定的函数或变量是extern类型的；extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。被extern "C"修饰的变量和函数是按照C语言方式编译和连接的。   

     4.与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。

二、extern“C”与__cplusplus

#ifdef __cplusplus
       extern "C" {
       #endif
       #ifdef __cplusplus
       }
       #endif
    Cplusplus（C plus plus）即"C++"，用于C++文档的头文件中，上面代码的意思是：如果是C++文件（*.cpp）后缀，则使用extern “C”，在C++项目中应用的非常广泛。即使用gcc编译器编译，函数名为C类型如_foo。个人认为，搞懂了这两个关键字，尤其是理解extern "C"（再次强调，不为过，呵呵），接下来的混合编程也就差不多了，哈哈哈。。。。
